use std::str::FromStr;

use anyhow::{bail, Context};
use reqwest::{StatusCode, Url};
use serde::{de::Visitor, Deserialize, Serialize};

use crate::utils::{BtError, BtResult};

/// Random peer id generated by running `openssl rand -base64 20 | head -c 20`.
const PEER_ID: &'static str = "l154rKqOHkfMLEGAecey";

/// Port.
const PORT: u16 = 6881;

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct PeerInfo {
    pub interval: usize,
    pub peers: Vec<Peer>,
}

#[derive(Debug, Clone, Serialize)]
pub struct Peer {
    pub ip: String,
    pub port: usize,
}

struct PeerVisitor;

impl<'de> Visitor<'de> for PeerVisitor {
    type Value = Peer;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("peer info string with 4 bytes IP addr and 2 bytes port number")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        let bytes = v.bytes();
        if bytes.len() == 6 {
            Ok(Self::Value {
                ip: String::from_utf8(bytes.clone().take(4).collect()).unwrap(),
                port: String::from_utf8(bytes.skip(4).collect())
                    .unwrap()
                    .parse()
                    .unwrap(),
            })
        } else {
            Err(E::custom(format!(
                "peer info string expected to have a 6 bytes length, actually got {}",
                bytes.len()
            )))
        }
    }
}

pub async fn discover_peer(
    tracker_url: &str,
    info_hash: &str,
    uploaded: usize,
    downloaded: usize,
    left: usize,
) -> BtResult<PeerInfo> {
    let mut url = Url::from_str(tracker_url).context("invalid url")?;
    url.set_query(Some(
        format!("info_hash={info_hash}&uploaded={uploaded}&downloaded={downloaded}&left={left}&compact=1&peer_id={PEER_ID}&port={PORT}")
            .as_str(),
    ));

    let resp = reqwest::get(url).await.context("http request failed")?;
    if resp.status() != StatusCode::OK {
        bail!(BtError::NetworkError(resp.status().as_u16()))
    }

    resp.bytes()
        .await
        .context("invalid resp data")
        .and_then(|data| {
            serde_json::from_slice::<PeerInfo>(data.iter().as_slice())
                .context("failed to deserialize peer info")
        })
}

impl<'de> Deserialize<'de> for Peer {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_str(PeerVisitor {})
    }
}
