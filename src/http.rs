use std::{
    borrow::Cow,
    ops::{Deref, DerefMut},
    str::FromStr,
};

use anyhow::{bail, Context, Result};
use reqwest::{StatusCode, Url};
use serde::{de::Visitor, Deserialize};
use tokio::{
    io::{AsyncReadExt, AsyncWriteExt},
    net::TcpStream,
};

use crate::{
    decode::{decode_bencoded_value, DecodeContext},
    utils::{decode_bytes_from_string, BtError, BtResult},
};

/// Random peer id generated by running `openssl rand -base64 20 | head -c 20`.
pub const PEER_ID: &'static str = "l154rKqOHkfMLEGAecey";

/// Port.
const PORT: &'static str = "6881";

#[derive(Debug, Clone)]
pub struct Peers(Vec<Peer>);

impl IntoIterator for Peers {
    type Item = Peer;
    type IntoIter = <Vec<Peer> as IntoIterator>::IntoIter;

    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

impl Deref for Peers {
    type Target = [Peer];

    fn deref(&self) -> &Self::Target {
        &self.0[..]
    }
}

impl DerefMut for Peers {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0[..]
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct PeerInfo {
    pub interval: usize,
    pub peers: Peers,
}

#[derive(Debug, Clone)]
pub struct Peer {
    pub ip: String,
    pub port: u16,
}

struct PeersVisitor;

impl<'de> Deserialize<'de> for Peers {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_bytes(PeersVisitor)
    }
}

impl<'de> Visitor<'de> for PeersVisitor {
    type Value = Peers;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("bytes array with length multiple of 6 bytes")
    }

    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        if v.len() % 6 != 0 {
            return Err(E::custom(
                "peer info bytes length is not multiple of 6 bytes",
            ));
        }

        let mut peers = vec![];
        for vv in v.chunks_exact(6) {
            let mut ip = String::new();
            ip.push_str(vv[0].to_string().as_str());
            ip.push('.');
            ip.push_str(vv[1].to_string().as_str());
            ip.push('.');
            ip.push_str(vv[2].to_string().as_str());
            ip.push('.');
            ip.push_str(vv[3].to_string().as_str());
            let port = u16::from_be_bytes([vv[4], vv[5]]);
            let peer = Peer { ip, port };
            peers.push(peer);
        }

        Ok(Peers(peers))
    }

    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        self.visit_bytes(v.as_slice())
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        let v = decode_bytes_from_string(v);
        self.visit_bytes(v.as_slice())
    }

    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        let v = decode_bytes_from_string(v.as_str());
        self.visit_bytes(v.as_slice())
    }
}

pub async fn discover_peer(
    tracker_url: &str,
    info_hash: &[u8; 20],
    uploaded: usize,
    downloaded: usize,
    left: usize,
) -> BtResult<PeerInfo> {
    let mut url = Url::from_str(tracker_url).context("invalid url")?;
    url.query_pairs_mut()
        .encoding_override(Some(&|input| {
            // Ref: https://app.codecrafters.io/courses/bittorrent/stages/fi9
            if input == "{{info_hash}}" {
                Cow::Owned(info_hash.to_vec())
            } else {
                Cow::Borrowed(input.as_bytes())
            }
        }))
        .append_pair("info_hash", "{{info_hash}}")
        .append_pair("uploaded", uploaded.to_string().as_str())
        .append_pair("downloaded", downloaded.to_string().as_str())
        .append_pair("left", left.to_string().as_str())
        .append_pair("compact", "1")
        .append_pair("peer_id", PEER_ID)
        .append_pair("port", PORT)
        .finish();

    let resp = reqwest::get(url).await.context("http request failed")?;
    if resp.status() != StatusCode::OK {
        bail!(BtError::NetworkError(resp.status().as_u16()))
    }

    resp.bytes()
        .await
        .context("invalid resp data")
        .and_then(|data| {
            decode_bencoded_value(&mut DecodeContext::new(data.as_ref().to_vec()))
                .context("bencode decode failed")
        })
        .and_then(|value| {
            serde_json::from_value::<PeerInfo>(value).context("failed to deserialize peer info")
        })
}

#[derive(Debug)]
pub struct HandshakeMessage {
    /// Sha1 info hash.
    pub info_hash: [u8; 20],

    /// Peer id in byte array.
    pub peer_id: [u8; 20],
}

impl HandshakeMessage {
    pub fn new(info_hash: [u8; 20], peer_id: [u8; 20]) -> Self {
        Self { info_hash, peer_id }
    }

    pub fn from_bytes(buffer: &[u8]) -> Result<Self> {
        if buffer.len() != 1 + 19 + 8 + 20 + 20 {
            bail!("invalid handshake message length: {}", buffer.len())
        }
        const HEADER_LEN: usize = 1 + 19 + 8;
        // TODO: Check header.
        let info_hash = buffer[HEADER_LEN..HEADER_LEN + 20]
            .iter()
            .map(|x| x.to_owned().to_owned())
            .collect::<Vec<_>>()
            .try_into()
            .unwrap();
        let peer_id = buffer[HEADER_LEN + 20..HEADER_LEN + 20 + 20]
            .iter()
            .map(|x| x.to_owned().to_owned())
            .collect::<Vec<_>>()
            .try_into()
            .unwrap();
        Ok(Self { info_hash, peer_id })
    }

    fn to_bytes(&self) -> Vec<u8> {
        let mut buffer = Vec::with_capacity(128);
        buffer.push(19);
        buffer.extend_from_slice(b"BitTorrent protocol");
        buffer.extend_from_slice(&[0u8; 8]);
        buffer.extend_from_slice(self.info_hash.as_slice());
        buffer.extend_from_slice(self.peer_id.as_slice());
        buffer
    }
}

pub async fn handshake(
    ip: &str,
    port: u16,
    message: HandshakeMessage,
) -> BtResult<HandshakeMessage> {
    let mut socket = TcpStream::connect(format!("{ip}:{port}").as_str())
        .await
        .context("failed to dial")?;
    let (mut rd, mut wr) = socket.split();
    if let Err(e) = wr.write_all(&message.to_bytes()).await {
        bail!("failed to send handshake message: {e}")
    }

    let mut buf = vec![0; 256];

    loop {
        let n = rd.read(&mut buf).await?;
        if n == 0 {
            break;
        }
        let resp =
            HandshakeMessage::from_bytes(&buf[0..n]).context("invalid resp message format")?;
        return Ok(resp);
    }

    bail!("empty responce");
}
