use std::{
    borrow::Cow,
    ops::{Deref, DerefMut},
    str::FromStr,
    sync::{Arc, Mutex},
};

use anyhow::{bail, Context, Result};
use reqwest::{StatusCode, Url};
use serde::{de::Visitor, Deserialize};
use sha1::{Digest, Sha1};
use tokio::{
    fs::OpenOptions,
    io::{AsyncReadExt, AsyncWriteExt},
    net::TcpStream,
};

use crate::{
    decode::{decode_bencoded_value, DecodeContext},
    http::piece_message::PieceMessage,
    torrent::Torrent,
    utils::{decode_bytes_from_string, parallel_future, BtError, BtResult},
};

/// Random peer id generated by running `openssl rand -base64 20 | head -c 20`.
pub const PEER_ID: &'static str = "l154rKqOHkfMLEGAecey";

/// Port.
const PORT: &'static str = "6881";

/// Size of each block in piece.
/// 16 kb.
const BLOCK_SIZE: usize = 16 * 1024;

#[derive(Debug, Clone)]
pub struct Peers(Vec<Peer>);

impl IntoIterator for Peers {
    type Item = Peer;
    type IntoIter = <Vec<Peer> as IntoIterator>::IntoIter;

    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

impl Deref for Peers {
    type Target = [Peer];

    fn deref(&self) -> &Self::Target {
        &self.0[..]
    }
}

impl DerefMut for Peers {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0[..]
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct PeerInfo {
    #[allow(dead_code)]
    pub interval: usize,

    pub peers: Peers,
}

#[derive(Debug, Clone)]
pub struct Peer {
    pub ip: String,
    pub port: u16,
}

struct PeersVisitor;

impl<'de> Deserialize<'de> for Peers {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_bytes(PeersVisitor)
    }
}

impl<'de> Visitor<'de> for PeersVisitor {
    type Value = Peers;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("bytes array with length multiple of 6 bytes")
    }

    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        if v.len() % 6 != 0 {
            return Err(E::custom(
                "peer info bytes length is not multiple of 6 bytes",
            ));
        }

        let mut peers = vec![];
        for vv in v.chunks_exact(6) {
            let mut ip = String::new();
            ip.push_str(vv[0].to_string().as_str());
            ip.push('.');
            ip.push_str(vv[1].to_string().as_str());
            ip.push('.');
            ip.push_str(vv[2].to_string().as_str());
            ip.push('.');
            ip.push_str(vv[3].to_string().as_str());
            let port = u16::from_be_bytes([vv[4], vv[5]]);
            let peer = Peer { ip, port };
            peers.push(peer);
        }

        Ok(Peers(peers))
    }

    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        self.visit_bytes(v.as_slice())
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        let v = decode_bytes_from_string(v);
        self.visit_bytes(v.as_slice())
    }

    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        let v = decode_bytes_from_string(v.as_str());
        self.visit_bytes(v.as_slice())
    }
}

pub async fn discover_peer(
    tracker_url: &str,
    info_hash: &[u8; 20],
    uploaded: usize,
    downloaded: usize,
    left: usize,
) -> BtResult<PeerInfo> {
    let mut url = Url::from_str(tracker_url).context("invalid url")?;
    url.query_pairs_mut()
        .encoding_override(Some(&|input| {
            // Ref: https://app.codecrafters.io/courses/bittorrent/stages/fi9
            if input == "{{info_hash}}" {
                Cow::Owned(info_hash.to_vec())
            } else {
                Cow::Borrowed(input.as_bytes())
            }
        }))
        .append_pair("info_hash", "{{info_hash}}")
        .append_pair("uploaded", uploaded.to_string().as_str())
        .append_pair("downloaded", downloaded.to_string().as_str())
        .append_pair("left", left.to_string().as_str())
        .append_pair("compact", "1")
        .append_pair("peer_id", PEER_ID)
        .append_pair("port", PORT)
        .finish();

    let resp = reqwest::get(url).await.context("http request failed")?;
    if resp.status() != StatusCode::OK {
        bail!(BtError::NetworkError(resp.status().as_u16()))
    }

    resp.bytes()
        .await
        .context("invalid resp data")
        .and_then(|data| {
            decode_bencoded_value(&mut DecodeContext::new(data.as_ref().to_vec()))
                .context("bencode decode failed")
        })
        .and_then(|value| {
            serde_json::from_value::<PeerInfo>(value).context("failed to deserialize peer info")
        })
}

#[derive(Debug)]
pub struct HandshakeMessage {
    /// Sha1 info hash.
    pub info_hash: [u8; 20],

    /// Peer id in byte array.
    pub peer_id: [u8; 20],
}

impl HandshakeMessage {
    pub fn new(info_hash: [u8; 20], peer_id: [u8; 20]) -> Self {
        Self { info_hash, peer_id }
    }

    /// The fixed handshake message length.
    pub const fn length() -> usize {
        1 + 19 + 8 + 20 + 20
    }

    pub fn from_bytes(buffer: &[u8]) -> Result<Self> {
        if buffer.len() != Self::length() {
            bail!(
                "warning: invalid handshake message length: {}, data={:?}",
                buffer.len(),
                buffer,
            )
        }
        const HEADER_LEN: usize = 1 + 19 + 8;
        // TODO: Check header.
        let info_hash = buffer[HEADER_LEN..HEADER_LEN + 20]
            .iter()
            .map(|x| x.to_owned().to_owned())
            .collect::<Vec<_>>()
            .try_into()
            .unwrap();
        let peer_id = buffer[HEADER_LEN + 20..HEADER_LEN + 20 + 20]
            .iter()
            .map(|x| x.to_owned().to_owned())
            .collect::<Vec<_>>()
            .try_into()
            .unwrap();
        Ok(Self { info_hash, peer_id })
    }

    fn to_bytes(&self) -> Vec<u8> {
        let mut buffer = Vec::with_capacity(128);
        buffer.push(19);
        buffer.extend_from_slice(b"BitTorrent protocol");
        buffer.extend_from_slice(&[0u8; 8]);
        buffer.extend_from_slice(self.info_hash.as_slice());
        buffer.extend_from_slice(self.peer_id.as_slice());
        buffer
    }
}

pub async fn handshake(
    ip: &str,
    port: u16,
    message: HandshakeMessage,
) -> BtResult<HandshakeMessage> {
    let mut socket = TcpStream::connect(format!("{ip}:{port}").as_str())
        .await
        .context("failed to dial")?;
    let (mut rd, mut wr) = socket.split();
    if let Err(e) = wr.write_all(&message.to_bytes()).await {
        bail!("failed to send handshake message: {e}")
    }

    let mut buf = vec![0; 256];

    loop {
        let n = rd.read(&mut buf).await?;
        if n == 0 {
            break;
        }
        let resp =
            HandshakeMessage::from_bytes(&buf[0..n]).context("invalid resp message format")?;
        return Ok(resp);
    }

    bail!("empty responce");
}

mod piece_message {
    use anyhow::bail;

    use crate::utils::BtResult;

    /// Different types of message when communicating piece download process.
    ///
    /// All types of `PieceMessage` have the same structure in order:
    ///
    /// * 4 bytes message length.
    /// * 1 byte message id.
    /// * message payload which occupies all remaining size.
    ///   * Not all messages have payload, payload may have different
    ///     sections that described by theirself's field.
    pub(crate) enum PieceMessage {
        /// Server returned message after handshake.
        Bitfield,

        /// Message sent to server.
        Interested,

        /// Server returns this message before we can make `Request`s.
        Unchoke,

        /// Request for a 16kb sized block data of the piece.
        ///
        /// Have payload.
        Request {
            /// Piece index, start from 0.
            index: u32,

            /// Byte offset in current piece, start from 0.
            begin: u32,

            /// Length of the block.
            ///
            /// Most blocks have 16kb data, the last one may have less than 16kb.
            length: u32,
        },

        /// A block of data of the piece responeded by other peers.
        ///
        /// Each `Piece` message has is corresponding to a `Request` message.
        ///
        /// Have payload.
        Piece {
            /// Piece index, start from 0.
            index: u32,

            /// Byte offset in current piece, start from 0.
            begin: u32,

            /// Data.
            ///
            /// Usually 16kb as the `Request` requested for.
            block: Vec<u8>,
        },
    }

    impl PieceMessage {
        pub fn new_interested() -> Self {
            Self::Interested
        }

        pub fn new_request(piece_index: u32, block_offset: u32, length: u32) -> Self {
            Self::Request {
                index: piece_index,
                begin: block_offset,
                length,
            }
        }

        pub const fn id(&self) -> u8 {
            match self {
                PieceMessage::Bitfield => 5,
                PieceMessage::Interested => 2,
                PieceMessage::Unchoke => 1,
                PieceMessage::Request { .. } => 6,
                PieceMessage::Piece { .. } => 7,
            }
        }

        fn length(&self) -> usize {
            match self {
                PieceMessage::Bitfield | PieceMessage::Interested | PieceMessage::Unchoke => 1,
                PieceMessage::Request { .. } => 13,
                PieceMessage::Piece { block, .. } => 9 + block.len(),
            }
        }

        pub(crate) fn to_bytes(&self) -> Vec<u8> {
            let mut buffer = Vec::with_capacity(8);
            buffer.extend_from_slice(&self.length().to_be_bytes());
            buffer.push(self.id());
            match self {
                PieceMessage::Request {
                    index,
                    begin,
                    length,
                } => {
                    buffer.extend_from_slice(&index.to_be_bytes());
                    buffer.extend_from_slice(&begin.to_be_bytes());
                    buffer.extend_from_slice(&length.to_be_bytes());
                }
                PieceMessage::Piece {
                    index,
                    begin,
                    block,
                } => {
                    buffer.extend_from_slice(&index.to_be_bytes());
                    buffer.extend_from_slice(&begin.to_be_bytes());
                    buffer.extend_from_slice(block.as_slice());
                }
                _ => { /* Do nothing */ }
            }
            buffer
        }

        pub(crate) fn from_bytes(data: &[u8]) -> BtResult<Self> {
            // 4 bytes length.
            if data.len() < 4 {
                bail!("data too short: length={}", data.len())
            }

            let length = u32::from_be_bytes([data[0], data[1], data[2], data[3]]);
            println!(">>> recv msg_id={}, length={}", &data[4], length);
            // |--------|--|------------|
            //   |       |           |
            // length    id          payload
            // (4 bytes) (1 byte)    (???)
            //
            // And the payload is:
            //
            // |--------|--------|------------------|
            //   |         |           |
            //   index    begin       block
            //  (4 bytes) (4 bytes)   (<= BLOCK_SIZE bytes)
            //
            // Payload  = index + begin + block
            // (length) =  4B   +  4B   + <=16384B
            //
            // `length` values is the sum length of `id` + `payload`.
            // And in `payload`, `index` and `begin` are not part of block data.
            //
            // So the `length` is: 1(id) + 4(index) + 4(begin) + BLOCK_SIZE, usually 16394.
            match data[4] {
                5 => Ok(Self::Bitfield),
                2 => Ok(Self::Interested),
                1 => Ok(Self::Unchoke),
                6 => bail!("unexpected request message"),
                7 => Self::piece_from_bytes(&data[5..(5 + (length - 1) as usize)]),
                v => bail!("unknown message id {v}"),
            }
        }

        /// Parse `PieceMessage::Piece` from bytes
        ///
        /// The data is the payload part of the message.
        fn piece_from_bytes(payload: &[u8]) -> BtResult<Self> {
            if payload.len() <= 8 {
                bail!("data too short for piece message: length={}", payload.len())
            }

            let index = u32::from_be_bytes([payload[0], payload[1], payload[2], payload[3]]);
            let begin = u32::from_be_bytes([payload[4], payload[5], payload[6], payload[7]]);
            let block = payload[8..].to_vec();
            Ok(Self::Piece {
                index,
                begin,
                block,
            })
        }
    }
}

#[derive(Debug)]
struct BlockTask {
    pub socket: Arc<Mutex<TcpStream>>,
    pub piece_index: usize,
    pub block_index: usize,
    pub block_size: usize,
    pub block_offset: usize,
}

struct BlockTaskResult {
    pub block_index: usize,
    pub data: Vec<u8>,
}

/// Download a single piece.
///
/// Steps:
///
/// 1. Handshake.
/// 2. Wait for a `bitfield` message.
/// 3. Send an `interested` message.
/// 4. Wait for an `unchoke` message.
/// 5. Break the piece into blocks, each block is 16kb sized. For each block:
///   1. Send a `request` message for each block.
///   2. Wait for a `piece` message.
pub async fn download_piece(
    torrent: &Torrent,
    peers: &Peers,
    file_path: String,
    piece_index: usize,
) -> BtResult<()> {
    let piece_length = torrent
        .piece_length(piece_index)
        .expect("piece index out of range");
    let m = piece_length % BLOCK_SIZE;
    let block_count = piece_length / BLOCK_SIZE + if m == 0 { 0 } else { 1 };
    // Last block size should be geater than zero.
    // If piece is exactly divided into multiple BLOCK_SIZE, the size of last one is also BLOCK_SIZE.
    let last_block_size = if m == 0 { BLOCK_SIZE } else { m };
    println!(
        ">>> piece_length={}, block_count={}, last_block_size={}",
        piece_length, block_count, last_block_size
    );

    let info_hash = torrent.info_hash();

    // Setup all connections.
    let peer_connections = parallel_future(peers.iter(), 3, |peer| {
        connect_peer(&peer, info_hash.clone())
    })
    .await
    .context("failed to setup peer connections")?
    .into_iter()
    .map(|conn| Arc::new(Mutex::new(conn)))
    .collect::<Vec<_>>();

    let mut tasks = vec![];
    for i in 0..block_count {
        tasks.push(BlockTask {
            socket: peer_connections[i % peer_connections.len()].clone(),
            piece_index: piece_index,
            block_index: i,
            block_size: if i < block_count - 1 {
                BLOCK_SIZE
            } else {
                last_block_size
            },
            block_offset: i * BLOCK_SIZE,
        });
    }

    // Download the first piece.
    // Request for the first piece.
    if std::fs::exists(&file_path).unwrap() {
        std::fs::remove_file(&file_path).unwrap();
    }

    println!(">>> parallel max size: {}", peer_connections.len());
    let mut data = parallel_future(tasks.into_iter(), peer_connections.len(), |task| {
        download_block(task)
    })
    .await?;
    data.sort_by(|x, y| x.block_index.cmp(&y.block_index));

    let mut output_file = OpenOptions::new()
        .write(true)
        .create(true)
        .append(true)
        .open(&file_path)
        .await
        .context("failed to open the output file")?;

    // Validate chksum.
    let mut hasher = Sha1::new();

    for block_data in data.iter() {
        output_file.write(&block_data.data).await.unwrap();
        hasher.update(&block_data.data);
    }

    let raw_chksum: [u8; 20] = hasher.finalize().try_into().unwrap();
    let chksum = hex::encode(raw_chksum);
    let expected_chksum = &torrent.info.piece_hashes[piece_index];
    println!(
        ">>> expect chksum: {}",
        expected_chksum
            .iter()
            .map(|x| x.to_owned() as char)
            .collect::<String>()
    );
    println!(">>> actual chksum: {}", chksum);

    Ok(())
}

async fn connect_peer(peer: &Peer, info_hash: [u8; 20]) -> BtResult<TcpStream> {
    /* Handshake */

    let message = HandshakeMessage::new(info_hash, PEER_ID.as_bytes().try_into().unwrap());

    println!(">>> handshake: ip={}, port={}", peer.ip, peer.port);
    let handshake_message_bytes = message.to_bytes();
    println!(">>> handshake request: {:?}", handshake_message_bytes);

    let mut socket = TcpStream::connect(format!("{}:{}", peer.ip, peer.port).as_str())
        .await
        .context("failed to dial")?;
    let (mut rd, mut wr) = socket.split();
    if let Err(e) = wr.write_all(&handshake_message_bytes).await {
        bail!("failed to send handshake message: {e}")
    }

    // Tempoary buffer.
    let mut buf = [0u8; 2048];

    let mut handshake_buf = vec![0u8; HandshakeMessage::length()];
    rd.read_exact(&mut handshake_buf).await?;
    // Here we ignore the handshake returned.
    let _ = HandshakeMessage::from_bytes(&handshake_buf).context("invalid resp message format")?;

    println!(">>> wait for bitfield");

    /* Wait for Bitfield */

    let n = rd.read(&mut buf).await?;
    if n == 0 {
        bail!("empty bitfield message");
    }

    match PieceMessage::from_bytes(&buf[0..n])? {
        PieceMessage::Bitfield => { /* Expected bitfield message */ }
        v => bail!("invalid bitfield message: id={}", v.id()),
    }

    println!(">>> send interested");

    /* Send Interested */

    wr.write(&PieceMessage::new_interested().to_bytes())
        .await
        .context("failed to write interested message")?;

    println!(">>> waiting unchoke");

    /* Wait for Unchoke */

    let n = rd.read(&mut buf).await?;
    if n == 0 {
        bail!(" empty bitfield message");
    }

    match PieceMessage::from_bytes(&buf[0..n])? {
        PieceMessage::Unchoke => { /* Expected unchoke message */ }
        v => bail!("invalid unchoke message: id={}", v.id()),
    }

    Ok(socket)
}

/// Download the data of a block in piece.
///
/// Each download process runs the entire handshake and download process.
///
/// The block info is specified in `task` parameter.
async fn download_block(task: BlockTask) -> BtResult<BlockTaskResult> {
    println!(">>> {}: requesting pieces.", task.block_index);
    let mut socket = task.socket.lock().unwrap();
    let (mut rd, mut wr) = socket.split();
    println!(">>> {}: **SOCKET LOCKED**", task.block_index);

    // Each piece is transfers as several blocks. The index of block defines the data position within piece.
    // let mut block_index = 0;

    let curr_block_offset = task.block_offset;
    let curr_block_size = task.block_size;
    println!(
        ">>> {} request: piece_index={}, block_index={}, block_offset={}, block_size={}",
        task.block_index, task.piece_index, task.block_index, curr_block_offset, curr_block_size
    );
    wr.write(
        &PieceMessage::new_request(
            task.piece_index as u32,
            curr_block_offset as u32,
            curr_block_size as u32,
        )
        .to_bytes(),
    )
    .await?;

    // Get all data for current block, it may be separated into different `read`s.
    // That's why we need a loop.

    // Record all bytes we read for current block.
    // Read until the block >= total_size.
    //
    // The total size is geater than `curr_block_size` because we have extra sections on data.
    let total_size = curr_block_size + 4 + 1 + 4 + 4;
    let mut blk_buf = vec![0u8; total_size];
    rd.read_exact(&mut blk_buf).await?;
    println!(">>> total_size={}, len={}", total_size, blk_buf.len());
    match PieceMessage::from_bytes(&blk_buf)? {
        PieceMessage::Piece {
            index,
            begin,
            block,
        } => {
            println!(
                ">>> receive: piece_index={}, block_index={}, begin={}, block_len={}",
                index,
                task.block_index,
                begin,
                block.len()
            );
            Ok(BlockTaskResult {
                block_index: task.block_index,
                data: block,
            })
        }
        v => bail!("{}: invalid message: id={}", task.block_index, v.id()),
    }
}
