use std::{
    borrow::Cow,
    ops::{Deref, DerefMut},
    str::FromStr,
    sync::{Arc, Mutex},
};

use anyhow::{bail, Context, Result};
use reqwest::{StatusCode, Url};
use serde::{de::Visitor, Deserialize};
use sha1::{Digest, Sha1};
use tokio::{
    io::{AsyncReadExt, AsyncWriteExt},
    net::TcpStream,
};

use crate::{
    decode::{decode_bencoded_value, DecodeContext},
    http::piece_message::PieceMessage,
    magnet::Magnet,
    torrent::Torrent,
    utils::{decode_bytes_from_string, parallel_future, BtError, BtResult},
};

/// Random peer id generated by running `openssl rand -base64 20 | head -c 20`.
pub const PEER_ID: &'static str = "l154rKqOHkfMLEGAecey";

/// Port.
const PORT: &'static str = "6881";

/// Size of each block in piece.
/// 16 kb.
const BLOCK_SIZE: usize = 16 * 1024;

const EXT_ID_MAP: [(&'static str, usize); 1] = [("ut_metadata", 1)];

#[derive(Debug, Clone)]
pub struct Peers(Vec<Peer>);

impl IntoIterator for Peers {
    type Item = Peer;
    type IntoIter = <Vec<Peer> as IntoIterator>::IntoIter;

    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

impl Deref for Peers {
    type Target = [Peer];

    fn deref(&self) -> &Self::Target {
        &self.0[..]
    }
}

impl DerefMut for Peers {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0[..]
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct PeerInfo {
    #[allow(dead_code)]
    pub interval: usize,

    pub peers: Peers,
}

#[derive(Debug, Clone)]
pub struct Peer {
    pub ip: String,
    pub port: u16,
}

struct PeersVisitor;

impl<'de> Deserialize<'de> for Peers {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_bytes(PeersVisitor)
    }
}

impl<'de> Visitor<'de> for PeersVisitor {
    type Value = Peers;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("bytes array with length multiple of 6 bytes")
    }

    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        if v.len() % 6 != 0 {
            return Err(E::custom(
                "peer info bytes length is not multiple of 6 bytes",
            ));
        }

        let mut peers = vec![];
        for vv in v.chunks_exact(6) {
            let mut ip = String::new();
            ip.push_str(vv[0].to_string().as_str());
            ip.push('.');
            ip.push_str(vv[1].to_string().as_str());
            ip.push('.');
            ip.push_str(vv[2].to_string().as_str());
            ip.push('.');
            ip.push_str(vv[3].to_string().as_str());
            let port = u16::from_be_bytes([vv[4], vv[5]]);
            let peer = Peer { ip, port };
            peers.push(peer);
        }

        Ok(Peers(peers))
    }

    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        self.visit_bytes(v.as_slice())
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        let v = decode_bytes_from_string(v);
        self.visit_bytes(v.as_slice())
    }

    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        let v = decode_bytes_from_string(v.as_str());
        self.visit_bytes(v.as_slice())
    }
}

pub async fn discover_peer(
    tracker_url: &str,
    info_hash: &[u8; 20],
    uploaded: usize,
    downloaded: usize,
    left: usize,
) -> BtResult<PeerInfo> {
    let mut url = Url::from_str(tracker_url).context("invalid url")?;
    url.query_pairs_mut()
        .encoding_override(Some(&|input| {
            // Ref: https://app.codecrafters.io/courses/bittorrent/stages/fi9
            if input == "{{info_hash}}" {
                Cow::Owned(info_hash.to_vec())
            } else {
                Cow::Borrowed(input.as_bytes())
            }
        }))
        .append_pair("info_hash", "{{info_hash}}")
        .append_pair("uploaded", uploaded.to_string().as_str())
        .append_pair("downloaded", downloaded.to_string().as_str())
        .append_pair("left", left.to_string().as_str())
        .append_pair("compact", "1")
        .append_pair("peer_id", PEER_ID)
        .append_pair("port", PORT)
        .finish();

    let resp = reqwest::get(url).await.context("http request failed")?;
    if resp.status() != StatusCode::OK {
        bail!(BtError::NetworkError(resp.status().as_u16()))
    }

    resp.bytes()
        .await
        .context("invalid resp data")
        .and_then(|data| {
            decode_bencoded_value(&mut DecodeContext::new(data.as_ref().to_vec()))
                .context("bencode decode failed")
        })
        .and_then(|value| {
            serde_json::from_value::<PeerInfo>(value).context("failed to deserialize peer info")
        })
}

#[derive(Debug)]
pub struct HandshakeMessage {
    /// Sha1 info hash.
    pub info_hash: [u8; 20],

    /// Peer id in byte array.
    pub peer_id: [u8; 20],

    /// The bytes in extension
    ext: Option<[u8; 8]>,
}

impl HandshakeMessage {
    pub fn new(info_hash: [u8; 20], peer_id: [u8; 20]) -> Self {
        Self {
            info_hash,
            peer_id,
            ext: None,
        }
    }

    pub fn with_ext(info_hash: [u8; 20], peer_id: [u8; 20], ext: [u8; 8]) -> Self {
        Self {
            info_hash,
            peer_id,
            ext: Some(ext),
        }
    }

    /// The fixed handshake message length.
    pub const fn length() -> usize {
        1 + 19 + 8 + 20 + 20
    }

    /// The fixed handshake message length with extension added.
    pub const fn ext_length() -> usize {
        1 + 19 + 8 + 20 + 20 + 6
    }

    pub fn has_ext(&self) -> bool {
        self.ext.is_some()
    }

    pub fn from_bytes(buffer: &[u8]) -> Result<Self> {
        if buffer.len() != Self::length() && buffer.len() != Self::ext_length() {
            println!(
                "warning: invalid handshake message length: {}, data={:?}",
                buffer.len(),
                buffer,
            )
        }
        const HEADER_LEN: usize = 1 + 19 + 8;
        // TODO: Check header.
        let info_hash = buffer[HEADER_LEN..HEADER_LEN + 20]
            .iter()
            .map(|x| x.to_owned().to_owned())
            .collect::<Vec<_>>()
            .try_into()
            .unwrap();
        let peer_id = buffer[HEADER_LEN + 20..HEADER_LEN + 20 + 20]
            .iter()
            .map(|x| x.to_owned().to_owned())
            .collect::<Vec<_>>()
            .try_into()
            .unwrap();
        let ext = match &buffer[1 + 19..1 + 19 + 8] {
            &[0, 0, 0, 0, 0, 0, 0, 0] => None,
            v => Some(v.to_owned().try_into().unwrap()),
        };
        Ok(Self {
            info_hash,
            peer_id,
            ext,
        })
    }

    fn to_bytes(&self) -> Vec<u8> {
        let mut buffer = Vec::with_capacity(128);
        buffer.push(19);
        buffer.extend_from_slice(b"BitTorrent protocol");
        buffer.extend_from_slice(&self.ext.unwrap_or([0u8; 8]));
        buffer.extend_from_slice(self.info_hash.as_slice());
        buffer.extend_from_slice(self.peer_id.as_slice());
        buffer
    }
}

pub async fn handshake(
    ip: &str,
    port: u16,
    message: HandshakeMessage,
) -> BtResult<HandshakeMessage> {
    let mut socket = TcpStream::connect(format!("{ip}:{port}").as_str())
        .await
        .context("failed to dial")?;
    let (mut rd, mut wr) = socket.split();
    if let Err(e) = wr.write_all(&message.to_bytes()).await {
        bail!("failed to send handshake message: {e}")
    }

    let mut buf = vec![0; 256];

    loop {
        let n = rd.read(&mut buf).await?;
        if n == 0 {
            break;
        }
        let resp =
            HandshakeMessage::from_bytes(&buf[0..n]).context("invalid resp message format")?;
        return Ok(resp);
    }

    bail!("empty responce");
}

mod piece_message {
    use anyhow::bail;

    use crate::{
        encode::{encode_dictionary, EncodeContext},
        utils::BtResult,
    };

    /// Different types of message when communicating piece download process.
    ///
    /// All types of `PieceMessage` have the same structure in order:
    ///
    /// * 4 bytes message length.
    /// * 1 byte message id.
    /// * message payload which occupies all remaining size.
    ///   * Not all messages have payload, payload may have different
    ///     sections that described by theirself's field.
    pub(crate) enum PieceMessage {
        /// Server returned message after handshake.
        Bitfield,

        /// Message sent to server.
        Interested,

        /// Server returns this message before we can make `Request`s.
        Unchoke,

        /// Request for a 16kb sized block data of the piece.
        ///
        /// Have payload.
        Request {
            /// Piece index, start from 0.
            index: u32,

            /// Byte offset in current piece, start from 0.
            begin: u32,

            /// Length of the block.
            ///
            /// Most blocks have 16kb data, the last one may have less than 16kb.
            length: u32,
        },

        /// A block of data of the piece responeded by other peers.
        ///
        /// Each `Piece` message has is corresponding to a `Request` message.
        ///
        /// Have payload.
        Piece {
            /// Piece index, start from 0.
            index: u32,

            /// Byte offset in current piece, start from 0.
            begin: u32,

            /// Data.
            ///
            /// Usually 16kb as the `Request` requested for.
            block: Vec<u8>,
        },

        /// Extension handshake.
        Extension {
            /// Bencoded dictionary.
            extensions: Vec<u8>,
        },
    }

    impl PieceMessage {
        pub fn new_interested() -> Self {
            Self::Interested
        }

        pub fn new_request(piece_index: u32, block_offset: u32, length: u32) -> Self {
            Self::Request {
                index: piece_index,
                begin: block_offset,
                length,
            }
        }

        pub fn new_extension(extensions: &[(&'static str, usize)]) -> Self {
            // The inner dictionary, pairs of extension name and extension id.
            let inner_dict = {
                let mut m: serde_json::Map<String, serde_json::Value> = serde_json::Map::new();
                for ext in extensions {
                    m.insert(
                        ext.0.to_string(),
                        serde_json::Value::Number(
                            serde_json::value::Number::from_i128(ext.1 as i128).unwrap(),
                        ),
                    );
                }
                m
            };

            // The outer dictionary, pairs of key "m" and inner dictionary
            let outer_dict = {
                let mut m: serde_json::Map<String, serde_json::Value> = serde_json::Map::new();
                m.insert(String::from("m"), serde_json::Value::Object(inner_dict));
                let mut ctx = EncodeContext::new();
                encode_dictionary(&mut ctx, &m);
                ctx.consume()
            };
            Self::Extension {
                extensions: outer_dict,
            }
        }

        pub const fn id(&self) -> u8 {
            match self {
                PieceMessage::Bitfield => 5,
                PieceMessage::Interested => 2,
                PieceMessage::Unchoke => 1,
                PieceMessage::Request { .. } => 6,
                PieceMessage::Piece { .. } => 7,
                PieceMessage::Extension { .. } => 20,
            }
        }

        /// The length of the message.
        fn length(&self) -> u32 {
            match self {
                PieceMessage::Bitfield | PieceMessage::Interested | PieceMessage::Unchoke => 1,
                PieceMessage::Request { .. } => 13,
                PieceMessage::Piece { block, .. } => 9 + block.len() as u32,
                PieceMessage::Extension { extensions } => 1 + 1 + extensions.len() as u32,
            }
        }

        pub(crate) fn to_bytes(&self) -> Vec<u8> {
            let mut buffer = Vec::with_capacity(8);
            buffer.extend_from_slice(&self.length().to_be_bytes());
            buffer.push(self.id());
            match self {
                PieceMessage::Request {
                    index,
                    begin,
                    length,
                } => {
                    buffer.extend_from_slice(&index.to_be_bytes());
                    buffer.extend_from_slice(&begin.to_be_bytes());
                    buffer.extend_from_slice(&length.to_be_bytes());
                }
                PieceMessage::Piece {
                    index,
                    begin,
                    block,
                } => {
                    buffer.extend_from_slice(&index.to_be_bytes());
                    buffer.extend_from_slice(&begin.to_be_bytes());
                    buffer.extend_from_slice(block.as_slice());
                }
                PieceMessage::Extension { extensions } => {
                    // Extension message id.
                    buffer.push(b'\x00');
                    // Extension message payload
                    buffer.extend_from_slice(extensions.as_slice());
                }
                _ => { /* Do nothing */ }
            }
            buffer
        }

        pub(crate) fn from_bytes(data: &[u8]) -> BtResult<Self> {
            // 4 bytes length.
            if data.len() < 4 {
                bail!("data too short: length={}", data.len())
            }

            let length = u32::from_be_bytes([data[0], data[1], data[2], data[3]]);
            // println!(">>> recv msg_id={}, length={}", &data[4], length);
            // |--------|--|------------|
            //   |       |           |
            // length    id          payload
            // (4 bytes) (1 byte)    (???)
            //
            // And the payload is:
            //
            // |--------|--------|------------------|
            //   |         |           |
            //   index    begin       block
            //  (4 bytes) (4 bytes)   (<= BLOCK_SIZE bytes)
            //
            // Payload  = index + begin + block
            // (length) =  4B   +  4B   + <=16384B
            //
            // `length` values is the sum length of `id` + `payload`.
            // And in `payload`, `index` and `begin` are not part of block data.
            //
            // So the `length` is: 1(id) + 4(index) + 4(begin) + BLOCK_SIZE, usually 16394.
            match data[4] {
                5 => Ok(Self::Bitfield),
                2 => Ok(Self::Interested),
                1 => Ok(Self::Unchoke),
                6 => bail!("unexpected request message"),
                7 => Self::piece_from_bytes(&data[5..(5 + (length - 1) as usize)]),
                20 => Self::extension_from_bytes(&data[5..(5 + (length - 1) as usize)]),
                v => bail!("unknown message id {v}"),
            }
        }

        /// Parse `PieceMessage::Piece` from bytes
        ///
        /// The data is the payload part of the message.
        fn piece_from_bytes(payload: &[u8]) -> BtResult<Self> {
            if payload.len() <= 8 {
                bail!("data too short for piece message: length={}", payload.len())
            }

            let index = u32::from_be_bytes([payload[0], payload[1], payload[2], payload[3]]);
            let begin = u32::from_be_bytes([payload[4], payload[5], payload[6], payload[7]]);
            let block = payload[8..].to_vec();
            Ok(Self::Piece {
                index,
                begin,
                block,
            })
        }

        /// Parse `PieceMessage::Extension` from bytes.
        fn extension_from_bytes(payload: &[u8]) -> BtResult<Self> {
            if payload.len() < 1 {
                bail!("data too short for piece message: length={}", payload.len())
            }

            Ok(Self::Extension {
                extensions: payload.to_vec(),
            })
        }
    }
}

#[derive(Debug)]
struct BlockTask {
    pub socket: Arc<Mutex<TcpStream>>,
    pub piece_index: usize,
    pub block_index: usize,
    pub block_size: usize,
    pub block_offset: usize,
}

struct BlockTaskResult {
    pub block_index: usize,
    pub data: Vec<u8>,
}

/// Download a single piece.
///
/// Steps:
///
/// 1. Handshake.
/// 2. Wait for a `bitfield` message.
/// 3. Send an `interested` message.
/// 4. Wait for an `unchoke` message.
/// 5. Break the piece into blocks, each block is 16kb sized. For each block:
///   1. Send a `request` message for each block.
///   2. Wait for a `piece` message.
pub async fn download_piece(
    torrent: &Torrent,
    peers: &Peers,
    file_path: String,
    piece_index: usize,
) -> BtResult<()> {
    let conns = setup_connection(peers, torrent.info_hash(), false)
        .await
        .context("failed to setup info hash")?;
    let piece_data = download_piece_internal(torrent, &conns, piece_index).await?;
    check_hash(&piece_data, &torrent.info.piece_hashes[piece_index]).context("")?;
    save_data_to_file(piece_data, &file_path).await
}

async fn download_piece_internal(
    torrent: &Torrent,
    peer_connections: &Vec<Arc<Mutex<TcpStream>>>,
    piece_index: usize,
) -> BtResult<Vec<u8>> {
    let piece_length = torrent
        .piece_length(piece_index)
        .expect("piece index out of range");
    let m = piece_length % BLOCK_SIZE;
    let block_count = piece_length / BLOCK_SIZE + if m == 0 { 0 } else { 1 };
    // Last block size should be geater than zero.
    // If piece is exactly divided into multiple BLOCK_SIZE, the size of last one is also BLOCK_SIZE.
    let last_block_size = if m == 0 { BLOCK_SIZE } else { m };
    println!(
        ">>> piece {}: piece_length={}, block_count={}, last_block_size={}",
        piece_index, piece_length, block_count, last_block_size
    );

    let mut tasks = vec![];
    for i in 0..block_count {
        tasks.push(BlockTask {
            socket: peer_connections[i % peer_connections.len()].clone(),
            piece_index: piece_index,
            block_index: i,
            block_size: if i < block_count - 1 {
                BLOCK_SIZE
            } else {
                last_block_size
            },
            block_offset: i * BLOCK_SIZE,
        });
    }

    // println!(">>> parallel max size: {}", peer_connections.len());
    let mut data = parallel_future(tasks.into_iter(), peer_connections.len(), |task| {
        download_block(task)
    })
    .await?;
    data.sort_by(|x, y| x.block_index.cmp(&y.block_index));

    Ok(data.into_iter().flat_map(|x| x.data).collect::<Vec<_>>())
}

/// Setup connections with all available peers.
async fn setup_connection(
    peers: &Peers,
    info_hash: &[u8; 20],
    enable_ext: bool,
) -> BtResult<Vec<Arc<Mutex<TcpStream>>>> {
    let conns = parallel_future(peers.iter(), 3, |peer| {
        connect_peer(&peer, info_hash.clone(), enable_ext)
    })
    .await
    .context("failed to setup peer connections")?
    .into_iter()
    .map(|conn| Arc::new(Mutex::new(conn.1.unwrap())))
    .collect::<Vec<_>>();

    Ok(conns)
}

/// Connect a single peer.
async fn connect_peer(
    peer: &Peer,
    info_hash: [u8; 20],
    enable_ext: bool,
) -> BtResult<(HandshakeMessage, Option<TcpStream>)> {
    /* Handshake */

    let message = if enable_ext {
        HandshakeMessage::with_ext(
            info_hash,
            PEER_ID.as_bytes().try_into().unwrap(),
            [0, 0, 0, 0, 0, 0x10, 0, 0],
        )
    } else {
        HandshakeMessage::new(info_hash, PEER_ID.as_bytes().try_into().unwrap())
    };

    println!(">>> handshake: ip={}, port={}", peer.ip, peer.port);
    let handshake_message_bytes = message.to_bytes();
    // println!(">>> handshake request: {:?}", handshake_message_bytes);

    let mut socket = TcpStream::connect(format!("{}:{}", peer.ip, peer.port).as_str())
        .await
        .context("failed to dial")?;
    let (mut rd, mut wr) = socket.split();
    if let Err(e) = wr.write_all(&handshake_message_bytes).await {
        bail!("failed to send handshake message: {e}")
    }

    // Tempoary buffer.
    let mut buf = [0u8; 2048];

    let mut handshake_buf = vec![0u8; HandshakeMessage::length()];
    rd.read_exact(&mut handshake_buf).await?;
    // Here we ignore the handshake returned.
    let handshake_resp =
        HandshakeMessage::from_bytes(&handshake_buf).context("invalid resp message format")?;

    // println!(">>> wait for bitfield");

    /* Wait for Bitfield */

    let n = rd.read(&mut buf).await?;
    if n == 0 {
        bail!("empty bitfield message");
    }

    match PieceMessage::from_bytes(&buf[0..n])? {
        PieceMessage::Bitfield => { /* Expected bitfield message */ }
        v => bail!("invalid bitfield message: id={}", v.id()),
    }

    // Only do the extension handshake if peer support.
    if enable_ext && handshake_resp.has_ext() {
        let bytes = PieceMessage::new_extension(&EXT_ID_MAP).to_bytes();
        println!(">>> [ext] start handshake: {:?}", &bytes);
        wr.write(&bytes)
            .await
            .context("failed to send extension message")?;
        // println!(">>> [ext] waiting response");
        // // Read the extension handshake response.
        // let n = rd.read(&mut buf).await?;
        // println!(">>> [ext] finish handshake, got: {:?}", &buf[0..n]);
        return Ok((handshake_resp, None));
    }

    // println!(">>> send interested");

    /* Send Interested */

    wr.write(&PieceMessage::new_interested().to_bytes())
        .await
        .context("failed to write interested message")?;

    // println!(">>> waiting unchoke");

    /* Wait for Unchoke */

    let n = rd.read(&mut buf).await?;
    if n == 0 {
        bail!(" empty unchoke message");
    }

    match PieceMessage::from_bytes(&buf[0..n])? {
        PieceMessage::Unchoke => { /* Expected unchoke message */ }
        v => bail!("invalid unchoke message: id={}", v.id()),
    }

    Ok((handshake_resp, Some(socket)))
}

/// Download the data of a block in piece.
///
/// Each download process runs the entire handshake and download process.
///
/// The block info is specified in `task` parameter.
async fn download_block(task: BlockTask) -> BtResult<BlockTaskResult> {
    let mut socket = task.socket.lock().unwrap();
    let (mut rd, mut wr) = socket.split();

    // Each piece is transfers as several blocks. The index of block defines the data position within piece.
    // let mut block_index = 0;

    let curr_block_offset = task.block_offset;
    let curr_block_size = task.block_size;
    // println!(
    //     ">>> {} request: piece_index={}, block_index={}, block_offset={}, block_size={}",
    //     task.block_index, task.piece_index, task.block_index, curr_block_offset, curr_block_size
    // );
    wr.write(
        &PieceMessage::new_request(
            task.piece_index as u32,
            curr_block_offset as u32,
            curr_block_size as u32,
        )
        .to_bytes(),
    )
    .await?;

    // Get all data for current block, it may be separated into different `read`s.
    // That's why we need a loop.

    // Record all bytes we read for current block.
    // Read until the block >= total_size.
    //
    // The total size is geater than `curr_block_size` because we have extra sections on data.
    let total_size = curr_block_size + 4 + 1 + 4 + 4;
    let mut blk_buf = vec![0u8; total_size];
    rd.read_exact(&mut blk_buf).await?;
    // println!(">>> total_size={}, len={}", total_size, blk_buf.len());
    match PieceMessage::from_bytes(&blk_buf)? {
        PieceMessage::Piece { block, .. } => {
            // println!(
            //     ">>> receive: piece_index={}, block_index={}, begin={}, block_len={}",
            //     index,
            //     task.block_index,
            //     begin,
            //     block.len()
            // );
            Ok(BlockTaskResult {
                block_index: task.block_index,
                data: block,
            })
        }
        v => bail!("{}: invalid message: id={}", task.block_index, v.id()),
    }
}

/// Download a whole file from torrent and save to `file_path`.
pub async fn download_file(torrent: &Torrent, peers: &Peers, file_path: String) -> BtResult<()> {
    let conns = setup_connection(peers, torrent.info_hash(), false)
        .await
        .context("failed to setup info hash")?;

    let mut file_data = vec![];
    for (idx, piece_hash) in torrent.info.piece_hashes.iter().enumerate() {
        println!(">>> downloading piece {idx}");
        let mut piece_data = download_piece_internal(torrent, &conns, idx)
            .await
            .with_context(|| format!("failed to download piece {idx} in file"))?;
        check_hash(&piece_data, &piece_hash)
            .with_context(|| format!("piece {idx} hash mismatch"))?;
        file_data.append(&mut piece_data);
        println!(">>> downloaded piece {idx}, file_size={}", file_data.len());
    }

    save_data_to_file(file_data, &file_path).await
}

fn check_hash(data: &[u8], expected_chksum: &[u8]) -> BtResult<()> {
    // Validate chksum.
    let mut hasher = Sha1::new();
    hasher.update(data);
    let raw_chksum: [u8; 20] = hasher.finalize().try_into().unwrap();
    let actual = hex::encode(raw_chksum);

    let expect = expected_chksum
        .iter()
        .map(|x| x.to_owned() as char)
        .collect::<String>();

    if actual != expect {
        Err(BtError::CheksumMismatchError {
            expected: expect,
            actually: actual,
        }
        .into())
    } else {
        Ok(())
    }
}

async fn save_data_to_file(data: Vec<u8>, file_path: &str) -> BtResult<()> {
    // Download the first piece.
    // Request for the first piece.
    if std::fs::exists(&file_path).unwrap() {
        std::fs::remove_file(&file_path).unwrap();
    }
    tokio::fs::write(file_path, data).await?;
    Ok(())
}

/// Magnet handshake queries peer info from tracker and handshake with peer to get peer id.
pub async fn magnet_handshake(magnet: &Magnet) -> BtResult<HandshakeMessage> {
    let mut tracker_url = match &magnet.tracker_url {
        Some(v) => Url::parse(v).context("invalid url")?,
        None => bail!("tracker url not provided"),
    };

    println!(">>> magnet handshake: tracker={}", tracker_url);
    tracker_url
        .query_pairs_mut()
        .encoding_override(Some(&|input| {
            // Ref: https://app.codecrafters.io/courses/bittorrent/stages/fi9
            if input == "{{info_hash}}" {
                Cow::Owned(magnet.info_hash.to_vec())
            } else {
                Cow::Borrowed(input.as_bytes())
            }
        }))
        .append_pair("info_hash", "{{info_hash}}")
        .append_pair("uploaded", "0")
        .append_pair("downloaded", "0")
        .append_pair("left", "1")
        .append_pair("compact", "1")
        .append_pair("peer_id", PEER_ID)
        .append_pair("port", PORT)
        .finish();

    let resp = reqwest::get(tracker_url)
        .await
        .context("http request failed")?;
    if resp.status() != StatusCode::OK {
        bail!(BtError::NetworkError(resp.status().as_u16()))
    }

    let peer_info = resp
        .bytes()
        .await
        .context("invalid resp data")
        .and_then(|data| {
            decode_bencoded_value(&mut DecodeContext::new(data.as_ref().to_vec()))
                .context("bencode decode failed")
        })
        .and_then(|value| {
            serde_json::from_value::<PeerInfo>(value).context("failed to deserialize peer info")
        })?;

    let peer = &peer_info.peers[0];
    let (resp, _) = connect_peer(peer, magnet.info_hash, true)
        .await
        .context("peer handshake failed")?;
    Ok(resp)
}
