use std::{
    borrow::Cow,
    ops::{Deref, DerefMut},
    str::FromStr,
};

use anyhow::{bail, Context};
use reqwest::{StatusCode, Url};
use serde::{de::Visitor, Deserialize};

use crate::{
    decode::{decode_bencoded_value, DecodeContext},
    utils::{decode_bytes_from_string, BtError, BtResult},
};

/// Random peer id generated by running `openssl rand -base64 20 | head -c 20`.
const PEER_ID: &'static str = "l154rKqOHkfMLEGAecey";

/// Port.
const PORT: &'static str = "6881";

#[derive(Debug, Clone)]
pub struct Peers(Vec<Peer>);

impl IntoIterator for Peers {
    type Item = Peer;
    type IntoIter = <Vec<Peer> as IntoIterator>::IntoIter;

    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

impl Deref for Peers {
    type Target = [Peer];

    fn deref(&self) -> &Self::Target {
        &self.0[..]
    }
}

impl DerefMut for Peers {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0[..]
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct PeerInfo {
    pub interval: usize,
    pub peers: Peers,
}

#[derive(Debug, Clone)]
pub struct Peer {
    pub ip: String,
    pub port: u16,
}

struct PeersVisitor;

impl<'de> Deserialize<'de> for Peers {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_bytes(PeersVisitor)
    }
}

impl<'de> Visitor<'de> for PeersVisitor {
    type Value = Peers;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("bytes array with length multiple of 6 bytes")
    }

    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        if v.len() % 6 != 0 {
            return Err(E::custom(
                "peer info bytes length is not multiple of 6 bytes",
            ));
        }

        let mut peers = vec![];
        for vv in v.chunks_exact(6) {
            let mut ip = String::new();
            ip.push_str(vv[0].to_string().as_str());
            ip.push('.');
            ip.push_str(vv[1].to_string().as_str());
            ip.push('.');
            ip.push_str(vv[2].to_string().as_str());
            ip.push('.');
            ip.push_str(vv[3].to_string().as_str());
            let port = u16::from_be_bytes([vv[4], vv[5]]);
            let peer = Peer { ip, port };
            peers.push(peer);
        }

        Ok(Peers(peers))
    }

    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        self.visit_bytes(v.as_slice())
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        let v = decode_bytes_from_string(v);
        self.visit_bytes(v.as_slice())
    }

    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        let v = decode_bytes_from_string(v.as_str());
        self.visit_bytes(v.as_slice())
    }
}

pub async fn discover_peer(
    tracker_url: &str,
    info_hash: &[u8; 20],
    uploaded: usize,
    downloaded: usize,
    left: usize,
) -> BtResult<PeerInfo> {
    let mut url = Url::from_str(tracker_url).context("invalid url")?;
    url.query_pairs_mut()
        .encoding_override(Some(&|input| {
            // Ref: https://app.codecrafters.io/courses/bittorrent/stages/fi9
            if input == "{{info_hash}}" {
                Cow::Owned(info_hash.to_vec())
            } else {
                Cow::Borrowed(input.as_bytes())
            }
        }))
        .append_pair("info_hash", "{{info_hash}}")
        .append_pair("uploaded", uploaded.to_string().as_str())
        .append_pair("downloaded", downloaded.to_string().as_str())
        .append_pair("left", left.to_string().as_str())
        .append_pair("compact", "1")
        .append_pair("peer_id", PEER_ID)
        .append_pair("port", PORT)
        .finish();

    let resp = reqwest::get(url).await.context("http request failed")?;
    if resp.status() != StatusCode::OK {
        bail!(BtError::NetworkError(resp.status().as_u16()))
    }

    resp.bytes()
        .await
        .context("invalid resp data")
        .and_then(|data| {
            decode_bencoded_value(&mut DecodeContext::new(data.as_ref().to_vec()))
                .context("bencode decode failed")
        })
        .and_then(|value| {
            serde_json::from_value::<PeerInfo>(value).context("failed to deserialize peer info")
        })
}
